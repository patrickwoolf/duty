<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>è‡ªå‹•æ’ç­å·¥å…·</title>
  <style>
    body { max-width: 900px; margin: auto; font-family: sans-serif; line-height: 1.6; }
    textarea { width: 100%; padding: 8px; margin-bottom: 12px; font-size: 1em; }
    label { font-weight: bold; margin-top: 8px; display: block; }
    pre { background: #f4f4f4; padding: 12px; overflow-x: auto; white-space: pre-wrap; }
    button { padding: 10px 20px; font-size: 1em; margin-right: 8px; }
    table { border-collapse: collapse; text-align: center; margin-top: 20px; width: 100%; }
    th, td { border: 1px solid #999; padding: 8px; }
  </style>
</head>
<body>
  <h1>ğŸ“… è‡ªå‹•æ’ç­å·¥å…·</h1>

  <label>å¹´ä»½</label>
  <textarea id="year" rows="1">2025</textarea>

  <label>æœˆä»½</label>
  <textarea id="month" rows="1">12</textarea>

  <label>è·ç´šäººå“¡</label>
  <textarea id="staffInput" rows="5">R2: AAA, BBB, CCC, DDD
R3: EEE, FFF, GGG, HHH
R4: III, JJJ, KKK</textarea>

  <label>é å€¼ç­</label>
  <textarea id="preAssignInput" rows="2">AAA: 5, 10; III: 6;</textarea>

  <label>ä¸èƒ½æ’ç­æ—¥</label>
  <textarea id="unavailableInput" rows="2">CCC: 8, 9;</textarea>

  <label>é»æ•¸ä¸Šé™</label>
  <textarea id="maxPointsInput" rows="1">R2: 5; R3: 4; R4: 3</textarea>

  <label>å¹³æ—¥ä¸Šé™</label>
  <textarea id="weekdayLimitInput" rows="1">AAA: 2;</textarea>

  <label>å‡æ—¥ä¸Šé™</label>
  <textarea id="weekendLimitInput" rows="1">CCC: 1;</textarea>

  <label>æœ¬æœˆç‰¹å®šæ—¥æœŸé»æ•¸</label>
  <textarea id="monthlyPointsInput" rows="1">5: 2, 10: 1, 15: 2</textarea>

  <button onclick="runScheduler()">åŸ·è¡Œæ’ç­</button>
  <button onclick="generateTable()">ç”¢ç”Ÿè¡¨æ ¼</button>

  <h2>ğŸ“‹ æ’ç­çµæœ</h2>
  <pre id="output">è«‹é»é¸ã€ŒåŸ·è¡Œæ’ç­ã€</pre>

  <div id="tableOutput"></div>

<script>
/* ------------ localStorageï¼šè‡ªå‹•è¨˜ä½æ¬„ä½å…§å®¹ -------------- */
const fields = [
  "year", "month", "staffInput", "preAssignInput", "unavailableInput",
  "maxPointsInput", "weekdayLimitInput", "weekendLimitInput", "monthlyPointsInput"
];

function loadSavedFields() {
  fields.forEach(id => {
    const saved = localStorage.getItem("scheduler_" + id);
    if (saved !== null) document.getElementById(id).value = saved;
  });
}

function enableAutoSave() {
  fields.forEach(id => {
    const el = document.getElementById(id);
    el.addEventListener("input", () => {
      localStorage.setItem("scheduler_" + id, el.value);
    });
  });
}

document.addEventListener("DOMContentLoaded", () => {
  loadSavedFields();
  enableAutoSave();
});
/* ----------------------------------------------------------- */

function parseNameDays(str) {
  const result = {};
  const parts = str.split(';');
  for (let part of parts) {
    if (!part.trim()) continue;
    const [name, days] = part.split(':');
    if (!name || !days) continue;
    result[name.trim()] = days.split(',').map(d => d.trim().padStart(2, '0'));
  }
  return result;
}

function parseLevelNames(str) {
  const result = {};
  const lines = str.split('\n');
  for (let line of lines) {
    const [level, names] = line.split(':');
    if (!level || !names) continue;
    result[level.trim()] = names.split(',').map(n => `${level.trim()}_${n.trim()}`);
  }
  return result;
}

function parseMaxPoints(str) {
  const result = {};
  const parts = str.split(';');
  for (let part of parts) {
    const [level, val] = part.split(':');
    if (!level || !val) continue;
    result[level.trim()] = parseInt(val);
  }
  return result;
}

function parseDatePoints(str) {
  const result = {};
  str.split(',').forEach(part => {
    const [date, val] = part.split(':').map(s => s.trim());
    if (date && val) {
      result[date.padStart(2, '0')] = parseInt(val);
    }
  });
  return result;
}

function shuffle(array) {
  for (let i = array.length -1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i +1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function calculateStats(schedule, staffLevels, year, month, monthlyPoints) {
  const pts = d => {
    if (monthlyPoints.hasOwnProperty(d)) return monthlyPoints[d];
    const day = new Date(year, month - 1, parseInt(d)).getDay();
    return (day === 0 || day === 6) ? 2 : 1;
  };
  const isWeekend = d => {
    const day = new Date(year, month - 1, parseInt(d)).getDay();
    return day === 0 || day === 6;
  };

  const allStaff = Object.values(staffLevels).flat();
  const stats = {};
  allStaff.forEach(p =>
    stats[p.split('_')[1]] = { totalPts: 0, weekday: 0, weekend: 0 }
  );

  for (const d in schedule) {
    const p = schedule[d];
    const shortName = p.split('_')[1];
    stats[shortName].totalPts += pts(d);
    isWeekend(d) ? stats[shortName].weekend++ : stats[shortName].weekday++;
  }
  return stats;
}

function runScheduler() {
  const year = +document.getElementById('year').value.trim();
  const month = +document.getElementById('month').value.trim();
  const dim = new Date(year, month, 0).getDate();
  const dates = Array.from({ length: dim }, (_, i) => String(i + 1).padStart(2, '0'));

  const staffLevels = parseLevelNames(document.getElementById('staffInput').value);
  const preAssign = parseNameDays(document.getElementById('preAssignInput').value);
  const unavailable = parseNameDays(document.getElementById('unavailableInput').value);

  const maxPoints = parseMaxPoints(document.getElementById('maxPointsInput').value);
  const weekdayLimit = parseMaxPoints(document.getElementById('weekdayLimitInput').value);
  const weekendLimit = parseMaxPoints(document.getElementById('weekendLimitInput').value);
  const monthlyPoints = parseDatePoints(document.getElementById('monthlyPointsInput').value);

  const allStaff = Object.values(staffLevels).flat();
  const nameMap = {};
  allStaff.forEach(n => nameMap[n.split('_')[1]] = n);

  const isWeekend = d => {
    const day = new Date(year, month - 1, parseInt(d)).getDay();
    return day === 0 || day === 6;
  };

  const pts = d => {
    if (monthlyPoints.hasOwnProperty(d)) return monthlyPoints[d];
    return isWeekend(d) ? 2 : 1;
  };

  const generateOneSchedule = () => {
    const daily = {};
    const assigned = {};
    const used = new Set();

    allStaff.forEach(p => assigned[p] = { dates: [], pts: 0, we: 0, wd: 0 });

    // å…ˆæ’é å€¼ç­
    for (const name in preAssign) {
      const staff = nameMap[name];
      if (!staff) continue;
      preAssign[name].forEach(d => {
        if (used.has(d)) return;
        daily[d] = staff;
        assigned[staff].dates.push(d);
        assigned[staff].pts += pts(d);
        isWeekend(d) ? assigned[staff].we++ : assigned[staff].wd++;
        used.add(d);
      });
    }

    const canAssign = (p, d) => {
      const shortName = p.split('_')[1];
      if (used.has(d)) return false;
      if (preAssign[shortName]?.includes(d)) return false;
      if (unavailable[shortName]?.includes(d)) return false;
      if (assigned[p].dates.some(dd => Math.abs(parseInt(dd) - parseInt(d)) <= 2)) return false;
      if (assigned[p].pts + pts(d) > maxPoints[p.slice(0, 2)]) return false;

      if (isWeekend(d)) {
        if (shortName in weekendLimit && assigned[p].we >= weekendLimit[shortName]) return false;
      } else {
        if (shortName in weekdayLimit && assigned[p].wd >= weekdayLimit[shortName]) return false;
      }
      return true;
    };

    for (const level in staffLevels) shuffle(staffLevels[level]);
    shuffle(allStaff);

    for (let d of dates) {
      if (used.has(d)) continue;

      for (let p of allStaff) {
        if (canAssign(p, d)) {
          daily[d] = p;
          assigned[p].dates.push(d);
          assigned[p].pts += pts(d);
          isWeekend(d) ? assigned[p].we++ : assigned[p].wd++;
          used.add(d);
          break;
        }
      }
    }

    return daily;
  };

  let results = [];
  const maxAttempts = 1000;
  let attempts = 0;

  while (results.length < 3 && attempts < maxAttempts) {
    attempts++;
    const schedule = generateOneSchedule();
    if (Object.keys(schedule).length === dates.length) results.push(schedule);
  }

  let output = '';
  if (results.length === 0) {
    output = 'âš ï¸ ç„¡æ³•æ‰¾åˆ°æœ‰æ•ˆæ’ç­çµæœã€‚';
  } else {
    results.forEach((res, idx) => {
      output += `\n\nğŸ”¶ ç¬¬ ${idx + 1} çµ„æœ‰æ•ˆæ’ç­\n`;
      dates.forEach(d => output += `${d} â¤ ${res[d].split('_')[1]}\n`);
    
      const stats = calculateStats(res, staffLevels, year, month, monthlyPoints);
      output += '\näººå“¡çµ±è¨ˆ (ç¸½é»æ•¸ / å¹³æ—¥ç­ / å‡æ—¥ç­)\n';
      for (const name in stats) {
        const s = stats[name];
        output += `${name} â¤ ${s.totalPts} / ${s.weekday} / ${s.weekend}\n`;
      }
    });
  }

  document.getElementById('output').textContent = output;
  document.getElementById('tableOutput').innerHTML = '';
}

function generateTable() {
  const outputText = document.getElementById('output').textContent;
  if (!outputText.includes('ç¬¬ 1 çµ„æœ‰æ•ˆæ’ç­')) return;
  const lines = outputText.split('\n').filter(l => l.includes('â¤'));
  let html = '<table><tr><th>æ—¥æœŸ</th><th>äººå“¡</th></tr>';
  lines.forEach(line => {
    const [date, name] = line.split('â¤').map(s => s.trim());
    html += `<tr><td>${date}</td><td>${name}</td></tr>`;
  });
  html += '</table>';
  document.getElementById('tableOutput').innerHTML = html;
}
</script>
</body>
</html>
