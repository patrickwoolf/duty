<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>è‡ªå‹•æ’ç­å·¥å…·</title>
  <style>
    body { max-width: 900px; margin: auto; font-family: sans-serif; line-height: 1.6; }
    textarea { width: 100%; padding: 8px; margin-bottom: 12px; font-size: 1em; }
    label { font-weight: bold; margin-top: 8px; display: block; }
    pre { background: #f4f4f4; padding: 12px; overflow-x: auto; white-space: pre-wrap; }
    button { padding: 10px 20px; font-size: 1em; margin-right: 8px; }
    table { border-collapse: collapse; text-align: center; margin-top: 20px; width: 100%; }
    th, td { border: 1px solid #999; padding: 8px; }
  </style>
</head>
<body>
  <h1>ğŸ“… è‡ªå‹•æ’ç­å·¥å…·</h1>

  <label>å¹´ä»½</label>
  <textarea id="year" rows="1">2025</textarea>

  <label>æœˆä»½</label>
  <textarea id="month" rows="1">8</textarea>

  <label>è·ç´šäººå“¡</label>
  <textarea id="staffInput" rows="5">R2: AAA, BBB, CCC, DDD
R3: EEE, FFF, GGG, HHH
R4: III, JJJ, KKK</textarea>

  <label>é å€¼ç­</label>
  <textarea id="preAssignInput" rows="2">AAA: 5, 10; III: 6;</textarea>

  <label>ä¸èƒ½æ’ç­æ—¥</label>
  <textarea id="unavailableInput" rows="2">CCC: 8, 9;</textarea>

  <!--
  <label>ä¸æ’å‡æ—¥åå–®</label>
  <textarea id="noWeekendInput" rows="1">FFF, III</textarea>

  <label>æ­·å²é»æ•¸</label>
  <textarea id="historyPointsInput" rows="1">AAA: 1; CCC: 2;</textarea>
  -->
  
  <label>é»æ•¸ä¸Šé™</label>
  <textarea id="maxPointsInput" rows="1">R2: 5; R3: 4; R4: 3</textarea>

  <label>å¹³æ—¥ä¸Šé™</label>
  <textarea id="weekdayLimitInput" rows="1">AAA: 2;</textarea>

  <label>å‡æ—¥ä¸Šé™</label>
  <textarea id="weekendLimitInput" rows="1">CCC: 1;</textarea>

  <!--
  <label>å‡æ—¥ç­æ’ç­é †åº</label>
  <textarea id="weekendOrderInput" rows="1">R4, R3, R2, R2</textarea>

  <label>å¹³æ—¥ç­æ’ç­é †åº</label>
  <textarea id="weekdayOrderInput" rows="1">R2, R3, R4, R2</textarea>
  -->
  
  <label>æœ¬æœˆç‰¹å®šæ—¥æœŸé»æ•¸</label>
  <textarea id="monthlyPointsInput" rows="1">5: 2, 10: 1, 15: 2</textarea>


  <button onclick="runScheduler()">åŸ·è¡Œæ’ç­</button>
  <button onclick="generateTable()">ç”¢ç”Ÿè¡¨æ ¼</button>

  <h2>ğŸ“‹ æ’ç­çµæœ</h2>
  <pre id="output">è«‹é»é¸ã€ŒåŸ·è¡Œæ’ç­ã€</pre>

  <div id="tableOutput"></div>

<script>
function parseNameDays(str) {
  const result = {};
  const parts = str.split(';');
  for (let part of parts) {
    if (!part.trim()) continue;
    const [name, days] = part.split(':');
    if (!name || !days) continue;
    result[name.trim()] = days.split(',').map(d => d.trim().padStart(2, '0'));
  }
  return result;
}

function parseLevelNames(str) {
  const result = {};
  const lines = str.split('\n');
  for (let line of lines) {
    const [level, names] = line.split(':');
    if (!level || !names) continue;
    result[level.trim()] = names.split(',').map(n => `${level.trim()}_${n.trim()}`);
  }
  return result;
}

function parseMaxPoints(str) {
  const result = {};
  const parts = str.split(';');
  for (let part of parts) {
    const [level, val] = part.split(':');
    if (!level || !val) continue;
    result[level.trim()] = parseInt(val);
  }
  return result;
}

function parseOrderInput(str) {
  return str.split(',').map(s => s.trim()).filter(Boolean);
}

function parseDatePoints(str) {
  const result = {};
  str.split(',').forEach(part => {
    const [date, val] = part.split(':').map(s => s.trim());
    if (date && val) {
      result[date.padStart(2, '0')] = parseInt(val);
    }
  });
  return result;
}


function shuffle(array) {
  for (let i = array.length -1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i +1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

let daily = {};
let assigned = {};
let staffLevels = {};
let year, month, dates = [];

function runScheduler() {
  year = +document.getElementById('year').value.trim();
  month = +document.getElementById('month').value.trim();
  const dim = new Date(year, month, 0).getDate();
  dates = Array.from({ length: dim }, (_, i) => String(i + 1).padStart(2, '0'));

  staffLevels = parseLevelNames(document.getElementById('staffInput').value);
  const preAssign = parseNameDays(document.getElementById('preAssignInput').value);
  const unavailable = parseNameDays(document.getElementById('unavailableInput').value);
  const noWeekend = new Set(document.getElementById('noWeekendInput').value.split(',').map(n => n.trim()));
  const historyPointsRaw = parseNameDays(document.getElementById('historyPointsInput').value);
  const maxPoints = parseMaxPoints(document.getElementById('maxPointsInput').value);
  const weekdayLimit = parseMaxPoints(document.getElementById('weekdayLimitInput').value);
  const weekendLimit = parseMaxPoints(document.getElementById('weekendLimitInput').value);
  const weekendOrder = parseOrderInput(document.getElementById('weekendOrderInput').value);
  const weekdayOrder = parseOrderInput(document.getElementById('weekdayOrderInput').value);

  const allStaff = Object.values(staffLevels).flat();
  const nameMap = {};
  allStaff.forEach(n => nameMap[n.split('_')[1]] = n);

  const isWeekend = d => {
    const day = new Date(year, month - 1, parseInt(d)).getDay();
    return day === 0 || day === 6;
  };
  const monthlyPoints = parseDatePoints(document.getElementById('monthlyPointsInput').value);

  const pts = d => {
    if (monthlyPoints.hasOwnProperty(d)) return monthlyPoints[d];
    const day = new Date(year, month - 1, parseInt(d)).getDay();
    return (day === 0 || day === 6) ? 2 : 1;
  };

  assigned = {};
  daily = {};
  const used = new Set();

  const historyPoints = {};
  for (const k in historyPointsRaw) {
    historyPoints[k] = historyPointsRaw[k].length;
  }

  allStaff.forEach(p => assigned[p] = { dates: [], pts: 0, we: 0, wd: 0 });

  for (const name in preAssign) {
    const staff = nameMap[name];
    if (!staff) continue;
    preAssign[name].forEach(d => {
      if (used.has(d)) return;
      daily[d] = staff;
      assigned[staff].dates.push(d);
      assigned[staff].pts += pts(d);
      isWeekend(d) ? assigned[staff].we++ : assigned[staff].wd++;
      used.add(d);
    });
  }

  function canAssign(p, d) {
    const shortName = p.split('_')[1];
    if (used.has(d)) return false;
    if (preAssign[shortName]?.includes(d)) return false;
    if (unavailable[shortName]?.includes(d)) return false;
    if (assigned[p].dates.some(dd => Math.abs(parseInt(dd) - parseInt(d)) <= 2)) return false;
    if (assigned[p].pts + pts(d) > maxPoints[p.slice(0, 2)]) return false;
    if (isWeekend(d) && noWeekend.has(shortName)) return false;

    if (isWeekend(d)) {
      if (shortName in weekendLimit && assigned[p].we >= weekendLimit[shortName]) return false;
    } else {
      if (shortName in weekdayLimit && assigned[p].wd >= weekdayLimit[shortName]) return false;
    }
    return true;
  }

  function assignOnceByLevelSequence(sequence, isWeekendRequired) {
    for (const level of sequence) {
      //alert(`ğŸ” æ’ç­è·ç´š: ${level}ï¼ˆ${isWeekendRequired ? 'å‡æ—¥' : 'å¹³æ—¥'}ï¼‰`);
      const group = staffLevels[level] || [];
      for (let p of group) {
        const already = assigned[p].dates.some(d => isWeekend(d) === isWeekendRequired);
        if (already) continue;
        const pick = dates.find(d => !used.has(d) && isWeekend(d) === isWeekendRequired && canAssign(p, d));
        if (pick) {
          daily[pick] = p;
          used.add(pick);
          assigned[p].dates.push(pick);
          assigned[p].pts += pts(pick);
          isWeekend(pick) ? assigned[p].we++ : assigned[p].wd++;
        }
      }
    }
  }


  for (const level in staffLevels) shuffle(staffLevels[level]);
  shuffle(allStaff);

  assignOnceByLevelSequence(weekendOrder, true);
  assignOnceByLevelSequence(weekdayOrder, false);

  for (let d of dates) {
    if (used.has(d)) continue;
    for (let p of allStaff) {
      if (canAssign(p, d)) {
        daily[d] = p;
        assigned[p].dates.push(d);
        assigned[p].pts += pts(d);
        isWeekend(d) ? assigned[p].we++ : assigned[p].wd++;
        used.add(d);
        break;
      }
    }
  }

  let output = 'ğŸ“… å€¼ç­æ—¥ â¤ äººå“¡\n';
  dates.forEach(d => {
    const p = daily[d];
    output += `${d} â¤ ${p ? p.split('_')[1] : 'âš ï¸ ç„¡æ³•æ’ç­'}\n`;
  });

  output += '\nğŸ“Š å“¡å·¥çµ±è¨ˆ\n';
  for (const level in staffLevels) {
    output += `\n== ${level} ==\n`;
    staffLevels[level].forEach(p => {
      const short = p.split('_')[1];
      const a = assigned[p];
      output += `${short}: ${a.pts} é»ï¼ˆå¹³${a.wd}, å‡${a.we}ï¼‰ â†’ [${a.dates.join(', ')}]\n`;
    });
  }

  document.getElementById('output').textContent = output;
  document.getElementById('tableOutput').innerHTML = '';
}

function generateTable() {
  if (!daily || Object.keys(daily).length === 0) {
    alert('è«‹å…ˆåŸ·è¡Œæ’ç­');
    return;
  }

  const dim = dates.length;
  const firstDayWeek = new Date(year, month - 1, 1).getDay();

  let html = '<table border="1" cellspacing="0" cellpadding="4">';
  html += '<thead><tr>';
  ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'æ—¥'].forEach(d => {
    html += `<th>å‘¨${d}</th>`;
  });
  html += '</tr></thead><tbody>';

  const emptyCells = firstDayWeek === 0 ? 6 : firstDayWeek - 1;
  const totalCells = dim + emptyCells;
  const weeks = Math.ceil(totalCells / 7);

  for (let w = 0; w < weeks; w++) {
    html += '<tr>';
    for (let wd = 0; wd < 7; wd++) {
      const cellIndex = w * 7 + wd;
      const dateNum = cellIndex - emptyCells + 1;
      if (cellIndex < emptyCells || dateNum > dim) {
        html += '<td></td>';
      } else {
        html += `<td><strong>${dateNum}</strong></td>`;
      }
    }
    html += '</tr><tr>';
    for (let wd = 0; wd < 7; wd++) {
      const cellIndex = w * 7 + wd;
      const dateNum = cellIndex - emptyCells + 1;
      if (cellIndex < emptyCells || dateNum > dim) {
        html += '<td></td>';
      } else {
        const d = String(dateNum).padStart(2, '0');
        const p = daily[d] ? daily[d].split('_')[1] : '';
        html += `<td>${p}</td>`;
      }
    }
    html += '</tr>';
  }

  html += '</tbody></table>';

  document.getElementById('tableOutput').innerHTML = html;
}
</script>
</body>
</html>
