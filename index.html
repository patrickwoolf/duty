<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>è‡ªå‹•æ’ç­å·¥å…·</title>
  <style>
    body { max-width: 900px; margin: auto; font-family: sans-serif; line-height: 1.6; }
    textarea, input { width: 100%; padding: 8px; margin-bottom: 12px; }
    label { font-weight: bold; margin-top: 8px; display: block; }
    pre { background: #f4f4f4; padding: 12px; overflow-x: auto; white-space: pre-wrap; }
    button { padding: 10px 20px; font-size: 1em; margin-right: 8px; }
    table { border-collapse: collapse; text-align: center; margin-top: 20px; width: 100%; }
    th, td { border: 1px solid #999; padding: 8px; }
  </style>
</head>
<body>
  <h1>ğŸ“… è‡ªå‹•æ’ç­å·¥å…·</h1>

  <label>å¹´ä»½ï¼š<input id="year" type="number" value="2025"></label>
  <label>æœˆä»½ï¼š<input id="month" type="number" value="8" min="1" max="12"></label>

  <label>è·ç´šäººå“¡</label>
  <textarea id="staffInput" rows="5">R2: AAA, BBB, CCC, DDD
R3: EEE, FFF, GGG, HHH
R4: III, JJJ, KKK</textarea>

  <label>é å€¼ç­</label>
  <textarea id="preAssignInput" rows="2">AAA: 5, 10; III: 6;</textarea>

  <label>ä¸èƒ½æ’ç­æ—¥</label>
  <textarea id="unavailableInput" rows="2">CCC: 8, 9;</textarea>

  <label>ä¸æ’å‡æ—¥åå–®</label>
  <input id="noWeekendInput" value="FFF, III" />

  <label>æ­·å²é»æ•¸</label>
  <textarea id="historyPointsInput" rows="1">AAA: 1; CCC: 2;</textarea>

  <label>é»æ•¸ä¸Šé™</label>
  <textarea id="maxPointsInput" rows="1">R2: 5; R3: 4; R4: 3</textarea>

  <label>å¹³æ—¥ä¸Šé™</label>
  <textarea id="weekdayLimitInput" rows="1">AAA: 2;</textarea>

  <label>å‡æ—¥ä¸Šé™</label>
  <textarea id="weekendLimitInput" rows="1">CCC: 1;</textarea>

  <button onclick="runScheduler()">åŸ·è¡Œæ’ç­</button>
  <button onclick="generateTable()">ç”¢ç”Ÿè¡¨æ ¼</button>

  <h2>ğŸ“‹ æ’ç­çµæœ</h2>
  <pre id="output">è«‹é»é¸ã€ŒåŸ·è¡Œæ’ç­ã€</pre>

  <div id="tableOutput"></div>

<script>
let daily = {};
let assigned = {};
let staffLevels = {};
let year, month, dates = [];

function parseNameDays(str) {
  const result = {};
  const parts = str.split(';');
  for (let part of parts) {
    if (!part.trim()) continue;
    const [name, days] = part.split(':');
    if (!name || !days) continue;
    result[name.trim()] = days.split(',').map(d => d.trim().padStart(2, '0'));
  }
  return result;
}

function parseKeyValue(str) {
  const result = {};
  const parts = str.split(';');
  for (let part of parts) {
    if (!part.trim()) continue;
    const [name, val] = part.split(':');
    if (!name || !val) continue;
    result[name.trim()] = parseInt(val.trim());
  }
  return result;
}

function parseLevelNames(str) {
  const result = {};
  const lines = str.split('\n');
  for (let line of lines) {
    const [level, names] = line.split(':');
    if (!level || !names) continue;
    result[level.trim()] = names.split(',').map(n => `${level.trim()}_${n.trim()}`);
  }
  return result;
}

function parseMaxPoints(str) {
  const result = {};
  const parts = str.split(';');
  for (let part of parts) {
    const [level, val] = part.split(':');
    if (!level || !val) continue;
    result[level.trim()] = parseInt(val);
  }
  return result;
}

function shuffle(array) {
  for (let i = array.length -1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i +1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function runScheduler() {
  year = +document.getElementById('year').value;
  month = +document.getElementById('month').value;
  const dim = new Date(year, month, 0).getDate();
  dates = Array.from({ length: dim }, (_, i) => String(i + 1).padStart(2, '0'));

  staffLevels = parseLevelNames(document.getElementById('staffInput').value);
  const preAssign = parseNameDays(document.getElementById('preAssignInput').value);
  const unavailable = parseNameDays(document.getElementById('unavailableInput').value);
  const noWeekend = new Set(document.getElementById('noWeekendInput').value.split(',').map(n => n.trim()));
  const historyPointsRaw = parseNameDays(document.getElementById('historyPointsInput').value);
  const maxPoints = parseMaxPoints(document.getElementById('maxPointsInput').value);
  const weekdayLimit = parseKeyValue(document.getElementById('weekdayLimitInput').value);
  const weekendLimit = parseKeyValue(document.getElementById('weekendLimitInput').value);

  const allStaff = Object.values(staffLevels).flat();
  const nameMap = {}; 
  allStaff.forEach(n => nameMap[n.split('_')[1]] = n);

  const isWeekend = d => {
    const day = new Date(year, month - 1, parseInt(d)).getDay();
    return day === 0 || day === 6;
  };
  const pts = d => isWeekend(d) ? 2 : 1;

  assigned = {};
  daily = {};
  const used = new Set();

  const historyPoints = {};
  for (const k in historyPointsRaw) {
    historyPoints[k] = historyPointsRaw[k].length;
  }

  allStaff.forEach(p => assigned[p] = { dates: [], pts: 0, we: 0, wd: 0 });

  for (const name in preAssign) {
    const staff = nameMap[name];
    if (!staff) continue;
    preAssign[name].forEach(d => {
      if (used.has(d)) return;
      daily[d] = staff;
      assigned[staff].dates.push(d);
      assigned[staff].pts += pts(d);
      isWeekend(d) ? assigned[staff].we++ : assigned[staff].wd++;
      used.add(d);
    });
  }

  function canAssign(p, d) {
    const shortName = p.split('_')[1];
    if (used.has(d)) return false;
    if (preAssign[shortName]?.includes(d)) return false;
    if (unavailable[shortName]?.includes(d)) return false;
    if (assigned[p].dates.some(dd => Math.abs(parseInt(dd) - parseInt(d)) <= 2)) return false;
    if (assigned[p].pts + pts(d) > maxPoints[p.slice(0, 2)]) return false;
    if (isWeekend(d) && noWeekend.has(shortName)) return false;

    // ğŸ‘‰ å¹³å‡æ—¥ä¸Šé™æ§åˆ¶
    if (isWeekend(d)) {
      if (shortName in weekendLimit && assigned[p].we >= weekendLimit[shortName]) return false;
    } else {
      if (shortName in weekdayLimit && assigned[p].wd >= weekdayLimit[shortName]) return false;
    }

    return true;
  }

  function assignOnce(group, isWeekendRequired) {
    for (let p of group) {
      const shortName = p.split('_')[1];
      const already = assigned[p].dates.some(d => isWeekend(d) === isWeekendRequired);
      if (already) continue;

      const pick = dates.find(d => !used.has(d) && isWeekend(d) === isWeekendRequired && canAssign(p, d));
      if (pick) {
        daily[pick] = p;
        used.add(pick);
        assigned[p].dates.push(pick);
        assigned[p].pts += pts(pick);
        isWeekend(pick) ? assigned[p].we++ : assigned[p].wd++;
      }
    }
  }

  for (const level in staffLevels) shuffle(staffLevels[level]);
  shuffle(allStaff);
  
  assignOnce(staffLevels.R4 || [], true);
  assignOnce(staffLevels.R3 || [], true);
  assignOnce(staffLevels.R2 || [], true);
  assignOnce(staffLevels.R2 || [], true);
  assignOnce(staffLevels.R2 || [], false);
  assignOnce(staffLevels.R4 || [], false);
  assignOnce(staffLevels.R3 || [], false);
  assignOnce(staffLevels.R2 || [], false);

  for (let d of dates) {
    if (used.has(d)) continue;
    for (let p of allStaff) {
      if (canAssign(p, d)) {
        daily[d] = p;
        assigned[p].dates.push(d);
        assigned[p].pts += pts(d);
        isWeekend(d) ? assigned[p].we++ : assigned[p].wd++;
        used.add(d);
        break;
      }
    }
  }

  let output = 'ğŸ“… å€¼ç­æ—¥ â¤ äººå“¡\n';
  dates.forEach(d => {
    const p = daily[d];
    output += `${d} â¤ ${p ? p.split('_')[1] : 'âš ï¸ ç„¡æ³•æ’ç­'}\n`;
  });

  output += '\nğŸ“Š å“¡å·¥çµ±è¨ˆ\n';
  for (const level in staffLevels) {
    output += `\n== ${level} ==\n`;
    staffLevels[level].forEach(p => {
      const short = p.split('_')[1];
      const a = assigned[p];
      output += `${short}: ${a.pts} é»ï¼ˆå¹³${a.wd}, å‡${a.we}ï¼‰ â†’ [${a.dates.join(', ')}]\n`;
    });
  }

  document.getElementById('output').textContent = output;
  document.getElementById('tableOutput').innerHTML = '';
}

function generateTable() {
  if (!daily || Object.keys(daily).length === 0) {
    alert('è«‹å…ˆåŸ·è¡Œæ’ç­');
    return;
  }

  const dim = dates.length;
  const firstDayWeek = new Date(year, month - 1, 1).getDay();

  let html = '<table border="1" cellspacing="0" cellpadding="4">';
  html += '<thead><tr>';
  ['ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'æ—¥'].forEach(d => {
    html += `<th>å‘¨${d}</th>`;
  });
  html += '</tr></thead><tbody>';

  const emptyCells = firstDayWeek === 0 ? 6 : firstDayWeek - 1;
  const totalCells = dim + emptyCells;
  const weeks = Math.ceil(totalCells / 7);

  for (let w = 0; w < weeks; w++) {
    html += '<tr>';
    for (let wd = 0; wd < 7; wd++) {
      const cellIndex = w * 7 + wd;
      const dateNum = cellIndex - emptyCells + 1;
      if (cellIndex < emptyCells || dateNum > dim) {
        html += '<td></td>';
      } else {
        html += `<td><strong>${dateNum}</strong></td>`;
      }
    }
    html += '</tr><tr>';
    for (let wd = 0; wd < 7; wd++) {
      const cellIndex = w * 7 + wd;
      const dateNum = cellIndex - emptyCells + 1;
      if (cellIndex < emptyCells || dateNum > dim) {
        html += '<td></td>';
      } else {
        const d = String(dateNum).padStart(2, '0');
        const p = daily[d] ? daily[d].split('_')[1] : '';
        html += `<td>${p}</td>`;
      }
    }
    html += '</tr>';
  }

  html += '</tbody></table>';

  document.getElementById('tableOutput').innerHTML = html;
}
</script>
</body>
</html>
